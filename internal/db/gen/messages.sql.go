// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: messages.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimQueued = `-- name: ClaimQueued :many
WITH picked AS (
  SELECT id
  FROM messages
  WHERE status = 'queued' AND send_after <= now()
  ORDER BY requested_at
  LIMIT $1
  FOR UPDATE SKIP LOCKED
)
UPDATE messages m
SET status = 'sending', attempts = attempts + 1
FROM picked
WHERE m.id = picked.id
RETURNING m.id
`

func (q *Queries) ClaimQueued(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.Query(ctx, claimQueued, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessage = `-- name: GetMessage :one
SELECT id, user_id, to_msisdn, body, status, provider_message_id, error_code,
       requested_at, sent_at, delivered_at, attempts
FROM messages
WHERE id = $1
`

type GetMessageRow struct {
	ID                string             `json:"id"`
	UserID            string             `json:"user_id"`
	ToMsisdn          string             `json:"to_msisdn"`
	Body              string             `json:"body"`
	Status            MsgStatus          `json:"status"`
	ProviderMessageID pgtype.Text        `json:"provider_message_id"`
	ErrorCode         pgtype.Text        `json:"error_code"`
	RequestedAt       pgtype.Timestamptz `json:"requested_at"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	DeliveredAt       pgtype.Timestamptz `json:"delivered_at"`
	Attempts          int32              `json:"attempts"`
}

func (q *Queries) GetMessage(ctx context.Context, id string) (GetMessageRow, error) {
	row := q.db.QueryRow(ctx, getMessage, id)
	var i GetMessageRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ToMsisdn,
		&i.Body,
		&i.Status,
		&i.ProviderMessageID,
		&i.ErrorCode,
		&i.RequestedAt,
		&i.SentAt,
		&i.DeliveredAt,
		&i.Attempts,
	)
	return i, err
}

const getMessageByIdemKey = `-- name: GetMessageByIdemKey :one
SELECT id
FROM messages
WHERE user_id = $1 AND idempotency_key = $2
`

type GetMessageByIdemKeyParams struct {
	UserID         string      `json:"user_id"`
	IdempotencyKey pgtype.Text `json:"idempotency_key"`
}

func (q *Queries) GetMessageByIdemKey(ctx context.Context, arg GetMessageByIdemKeyParams) (string, error) {
	row := q.db.QueryRow(ctx, getMessageByIdemKey, arg.UserID, arg.IdempotencyKey)
	var id string
	err := row.Scan(&id)
	return id, err
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO messages (user_id, to_msisdn, body, status, idempotency_key)
VALUES (
  $1,
  $2,
  $3,
  'queued',
  $4     
)
RETURNING id
`

type InsertMessageParams struct {
	UserID         string      `json:"user_id"`
	ToMsisdn       string      `json:"to_msisdn"`
	Body           string      `json:"body"`
	IdempotencyKey pgtype.Text `json:"idempotency_key"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (string, error) {
	row := q.db.QueryRow(ctx, insertMessage,
		arg.UserID,
		arg.ToMsisdn,
		arg.Body,
		arg.IdempotencyKey,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const listMessages = `-- name: ListMessages :many
SELECT id, user_id, to_msisdn, body, status, provider_message_id, error_code,
       requested_at, sent_at, delivered_at, attempts
FROM messages
WHERE user_id = $1
  AND ($2::msg_status     IS NULL OR status       = $2::msg_status)
  AND ($3::timestamptz   IS NULL OR requested_at >= $3::timestamptz)
  AND ($4::timestamptz     IS NULL OR requested_at <  $4::timestamptz)
ORDER BY requested_at DESC
LIMIT  $6
OFFSET $5
`

type ListMessagesParams struct {
	UserID  string             `json:"user_id"`
	Status  NullMsgStatus      `json:"status"`
	FromTs  pgtype.Timestamptz `json:"from_ts"`
	ToTs    pgtype.Timestamptz `json:"to_ts"`
	OffsetN int32              `json:"offset_n"`
	LimitN  int32              `json:"limit_n"`
}

type ListMessagesRow struct {
	ID                string             `json:"id"`
	UserID            string             `json:"user_id"`
	ToMsisdn          string             `json:"to_msisdn"`
	Body              string             `json:"body"`
	Status            MsgStatus          `json:"status"`
	ProviderMessageID pgtype.Text        `json:"provider_message_id"`
	ErrorCode         pgtype.Text        `json:"error_code"`
	RequestedAt       pgtype.Timestamptz `json:"requested_at"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	DeliveredAt       pgtype.Timestamptz `json:"delivered_at"`
	Attempts          int32              `json:"attempts"`
}

func (q *Queries) ListMessages(ctx context.Context, arg ListMessagesParams) ([]ListMessagesRow, error) {
	rows, err := q.db.Query(ctx, listMessages,
		arg.UserID,
		arg.Status,
		arg.FromTs,
		arg.ToTs,
		arg.OffsetN,
		arg.LimitN,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesRow
	for rows.Next() {
		var i ListMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ToMsisdn,
			&i.Body,
			&i.Status,
			&i.ProviderMessageID,
			&i.ErrorCode,
			&i.RequestedAt,
			&i.SentAt,
			&i.DeliveredAt,
			&i.Attempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadMessageForSend = `-- name: LoadMessageForSend :one
SELECT user_id, to_msisdn, body
FROM messages
WHERE id = $1
`

type LoadMessageForSendRow struct {
	UserID   string `json:"user_id"`
	ToMsisdn string `json:"to_msisdn"`
	Body     string `json:"body"`
}

func (q *Queries) LoadMessageForSend(ctx context.Context, id string) (LoadMessageForSendRow, error) {
	row := q.db.QueryRow(ctx, loadMessageForSend, id)
	var i LoadMessageForSendRow
	err := row.Scan(&i.UserID, &i.ToMsisdn, &i.Body)
	return i, err
}

const markFailed = `-- name: MarkFailed :exec
UPDATE messages
SET status='failed'
WHERE id = $1
`

func (q *Queries) MarkFailed(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, markFailed, id)
	return err
}

const markFailedAndRefund = `-- name: MarkFailedAndRefund :exec
WITH upd AS (
  UPDATE messages AS m
  SET status = 'failed'
  WHERE m.id = $1
    AND status <> 'failed'
  RETURNING user_id
)
UPDATE users AS u
SET balance = balance + 1
WHERE u.id = (SELECT user_id FROM upd)
`

func (q *Queries) MarkFailedAndRefund(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, markFailedAndRefund, id)
	return err
}

const markSent = `-- name: MarkSent :exec
UPDATE messages
SET status = 'sent', provider_message_id = $2, sent_at = now()
WHERE id = $1
`

type MarkSentParams struct {
	ID                string      `json:"id"`
	ProviderMessageID pgtype.Text `json:"provider_message_id"`
}

func (q *Queries) MarkSent(ctx context.Context, arg MarkSentParams) error {
	_, err := q.db.Exec(ctx, markSent, arg.ID, arg.ProviderMessageID)
	return err
}

const requeueWithBackoff = `-- name: RequeueWithBackoff :exec
UPDATE messages
SET status = 'queued',
    send_after = now() + ($1 || ' seconds')::interval
WHERE id = $2
`

type RequeueWithBackoffParams struct {
	Seconds pgtype.Text `json:"seconds"`
	ID      string      `json:"id"`
}

func (q *Queries) RequeueWithBackoff(ctx context.Context, arg RequeueWithBackoffParams) error {
	_, err := q.db.Exec(ctx, requeueWithBackoff, arg.Seconds, arg.ID)
	return err
}
